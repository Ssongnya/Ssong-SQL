# 팔로우 기능 구현

## 프로필 페이지

### 프로필 페이지

- 각 회원의 **개인 프로필 페이지**에 팔로우 기능을 구현하기 위해 우선적으로 프로필 페이지를 구성함  
- 프로필 페이지에서는 해당 사용자의 **추가 정보**를 함께 볼 수 있도록 다음 내용을 포함함  

#### 프로필 페이지에 포함될 주요 정보
- 해당 사용자가 작성한 **게시글 목록**
- 해당 사용자가 작성한 **댓글 목록**
- 해당 사용자가 **좋아요를 누른 게시글 목록**

---

### 프로필 페이지 구현

#### 1. 프로필 페이지의 목적
- 팔로우 기능을 구현하기 전에, 각 회원의 **개인 프로필 페이지**를 먼저 만들어야 함  
- 프로필 페이지에서는 해당 사용자의 **작성 글, 댓글, 좋아요한 글** 등을 함께 볼 수 있도록 구성  


#### 2. URL 설정
- 프로필은 사용자와 관련된 기능이므로 `'accounts'` 앱의 `urls.py`에 작성  
- 로그인한 사용자뿐 아니라 **다른 사용자의 프로필**에도 접근 가능해야 함  
- 이를 위해 `username`을 **variable routing**으로 전달하여 접근하도록 설정  
  - 예: `/accounts/profile/<username>/`  


#### 3. View 함수 작성
- URL로 전달된 `username`을 사용하여 해당 사용자의 정보를 조회  
- `User` 모델은 직접 import하지 않고 `get_user_model()` 함수를 통해 가져옴  
- 조회한 사용자 정보를 `context`에 담아 `profile.html`로 전달  
- 즉, 프로필 페이지는 특정 사용자의 정보를 템플릿으로 렌더링하는 역할  


#### 4. Template 구성 (`profile.html`)
- 프로필 페이지에는 다음 정보들이 표시됨:
  - 사용자의 이름 (`{{ person.username }}`)
  - 사용자가 작성한 게시글 목록 (`person.article_set.all`)
  - 사용자가 작성한 댓글 목록 (`person.comment_set.all`)
  - 사용자가 좋아요를 누른 게시글 목록 (`person.like_articles.all`)

#### 5. 프로필 페이지로 이동할 수 있는 링크 추가
- `index.html`(게시글 목록 페이지)에서 프로필 페이지로 이동할 수 있도록 링크 추가  
- 로그인한 사용자의 경우:
  - 본인 프로필로 이동하는 “내 프로필” 링크를 표시  
  - `{% url 'accounts:profile' user.username %}` 형태로 연결  
- 다른 사용자의 경우:
  - 게시글 작성자 이름(`{{ article.user }}`)을 클릭하면 해당 사용자의 프로필로 이동  
  - `{% url 'accounts:profile' article.user.username %}` 형태로 설정  


---

## 모델 관계 설정

### 팔로우 기능의 모델 관계

#### 1. 개념 이해
- 팔로우(Follow)는 **유저와 유저 간의 관계**를 의미함  
- 한 사용자는 여러 명의 다른 사용자를 팔로우할 수 있으며,  
  동시에 여러 명의 사용자로부터 팔로우를 받을 수도 있음  
- 즉, `User(M) - User(N)` 구조의 **다대다(M:N) 관계**로 표현 가능  

#### 2. 모델 설계
- 팔로우 관계는 **User 모델 내부에서 자기 자신과의 관계(Self-Relation)** 로 표현됨  
- 이를 위해 Django의 `ManyToManyField`를 사용  
- `symmetrical=False`로 설정해야 **단방향 관계(서로 자동으로 연결되지 않음)** 를 구현할 수 있음  
  - 예: A가 B를 팔로우하더라도, B가 A를 자동으로 팔로우하지 않음  
- `related_name='followers'`를 지정하여 역참조 시 명확하게 구분할 수 있도록 설정  

#### 3. 필드 역할 정리
- `followings` : 내가 팔로우하는 사람들의 목록  
- `followers` : 나를 팔로우하는 사람들의 목록 (역참조)  
- 이 설정을 통해 각 사용자는 다음과 같이 관계를 쉽게 조회할 수 있음:
  - `user.followings.all()` → 내가 팔로우하는 사용자들  
  - `user.followers.all()` → 나를 팔로우하는 사용자들  

#### ✅ 정리
- 팔로우 기능은 `User` 모델 내부에서 **ManyToManyField(self)** 로 구현  
- 단방향 관계를 위해 `symmetrical=False` 설정  
- 명확한 역참조 이름을 위해 `related_name='followers'` 지정  
- 결과적으로 한 사용자가 여러 명을 팔로우하거나, 여러 명에게 팔로우받는 구조를 손쉽게 표현 가능


---

## 기능 구현

### 팔로우 기능 구현

#### 1. URL 설정
- 팔로우 기능은 특정 사용자를 대상으로 수행되므로, **variable routing**을 활용하여 사용자 정보를 전달해야 함  
- `'accounts/urls.py'`에 팔로우 기능을 위한 URL 패턴 추가  
  - `/accounts/<int:user_pk>/follow/` 형태로 접근  
  - `user_pk`를 통해 팔로우 대상 사용자를 식별  


#### 2. View 함수 작성
- 팔로우 요청은 로그인된 사용자만 수행 가능하므로 `@login_required` 데코레이터 적용  
- 전달받은 `user_pk`를 이용해 팔로우 대상(`person`)을 조회  
- 조건 처리:
  - **본인 자신은 팔로우 불가**  
  - 중개 테이블에 이미 `request.user`가 존재하면 → **언팔로우 (삭제)**  
  - 존재하지 않으면 → **팔로우 (추가)**  
- 작업 후에는 프로필 페이지로 리다이렉트하여 결과 확인 가능  


#### 3. 프로필 페이지에 팔로우 정보 표시
- 프로필 화면에서 해당 사용자의 **팔로잉 수**와 **팔로워 수**를 함께 출력  
- DTL의 `|length` 필터를 사용하여 개수 표시  
  - `person.followings.all|length` → 팔로잉 수  
  - `person.followers.all|length` → 팔로워 수  
- 이를 통해 사용자의 인맥 규모를 한눈에 확인할 수 있음  


#### 4. 팔로우/언팔로우 버튼 추가
- 프로필 페이지에서 로그인된 사용자(`request.user`)가  
  현재 보고 있는 프로필의 사용자(`person`)와 **다를 경우에만 버튼 표시**  
- 팔로우 상태에 따라 버튼 텍스트를 다르게 출력:
  - 이미 팔로우 중이면 “Unfollow”  
  - 팔로우하지 않았다면 “Follow”  
- 버튼 클릭 시 `accounts:follow` URL로 POST 요청이 전달되어  
  View 함수에서 팔로우/언팔로우 동작을 수행  


#### 5. 기능 확인
- 프로필 페이지에서 **팔로우 버튼 클릭 시** 즉시 상태가 반영되는지 확인  
  - 팔로워/팔로잉 숫자가 실시간으로 변경  
  - 버튼 텍스트도 Follow ↔ Unfollow로 바뀜  
- 데이터베이스의 중개 테이블(`auth_user_followings`)에서  
  `from_user_id`(팔로우한 사람)과 `to_user_id`(팔로우된 사람)의 관계로 데이터가 저장됨  


#### ✅ 정리
- 팔로우 기능은 **ManyToManyField(self)** 로 정의된 사용자 간 관계를 활용  
- 핵심 구성 요소:
  1. **URL**: variable routing으로 대상 유저 식별 (`user_pk`)
  2. **View**: 팔로우 상태에 따라 add/remove 처리
  3. **Template**: 팔로워/팔로잉 수 및 버튼 UI 구현
- 결과적으로 사용자는 **서로 다른 유저 간 팔로우 관계를 실시간으로 관리**할 수 있음

---
**여기서 부터는 그냥 알면 좋은 내용**

# Fixtures


- **Fixtures**는 Django 개발 시 **데이터베이스 초기화 및 공유를 위해 사용되는 파일 형식**임  
- 주로 JSON 형태의 파일로, 프로젝트 내에서 초기 데이터나 샘플 데이터를 저장하고 불러오는 데 활용됨  


### 사용 목적
- **초기 데이터 세팅**
  - 웹 서비스가 처음 시작될 때 필요한 기본 데이터를 미리 세팅하기 위해 사용  
  - 예: 기본 권한 그룹, 상품 카테고리 등  

- **테스트 샘플 데이터 준비**
  - 테스트 환경에서 항상 동일하고 예측 가능한 데이터를 제공  
  - 테스트의 신뢰성과 반복 가능성을 높임  

- **협업 시 동일한 데이터 환경 유지**
  - 여러 개발자가 동일한 초기 데이터나 테스트 데이터를 공유할 수 있도록 함  
  - 팀 내 개발 환경의 일관성을 유지하고 협업 효율을 향상시킴  


### 초기 데이터의 필요성
- 협업 시 `.gitignore`에 의해 **데이터베이스(DB)는 업로드되지 않기 때문에**,  
  한 개발자가 생성한 데이터는 다른 개발자에게 자동으로 전달되지 않음  
- 따라서 새로 클론한 프로젝트는 **빈 데이터베이스 상태**로 시작하게 됨  
- 이를 해결하기 위해 Django는 **fixtures 파일을 사용하여 초기 데이터를 제공**함  
  - 동일한 초기 데이터를 미리 정의해두면, 프로젝트를 새로 설정할 때 손쉽게 데이터베이스를 채울 수 있음  

### 관련 명령어

#### `dumpdata` (추출)
- 데이터베이스의 데이터를 파일로 **내보낼 때 사용**
- 주로 **JSON 형식**으로 추출됨  
- 특정 앱이나 테이블의 데이터만 선택적으로 추출 가능  
- 사용 예시:
  - `python manage.py dumpdata appname.ModelName > data.json`

#### `loaddata` (로드)
- 저장된 fixture 파일(JSON 등)을 **데이터베이스로 불러올 때 사용**
- 내보낸 데이터 파일을 읽어서 DB에 삽입함  
- 사용 예시:
  - `python manage.py loaddata data.json`


### 정리
- Fixtures는 **초기 데이터 공유와 재현 가능한 테스트 환경 구축**에 필수적임  
- 협업 시 동일한 데이터 상태를 보장해 개발 환경을 통일시킬 수 있음  
- 핵심 명령어  
  - `dumpdata` → 데이터 추출  
  - `loaddata` → 데이터 불러오기  
- 결과적으로 **팀 단위 개발, 테스트 자동화, 데이터 복구 등** 다양한 상황에서 효율적인 데이터 관리가 가능함


---

## dumpdata


- `dumpdata`는 **데이터베이스의 특정 모델 혹은 앱 전체 데이터를 추출하는 명령어**  
- 데이터베이스 내용을 JSON, YAML 등 다양한 형식으로 내보낼 수 있으며  
  주로 **초기 데이터(Initial Data) 저장이나 공유용 Fixture 파일 생성**에 사용됨  


### dumpdata 기본 명령어 형식
```bash
$ python manage.py dumpdata [앱이름.모델이름] [옵션] > 추출파일명.json
```

- 앱 이름만 지정: 해당 앱의 모든 모델 데이터를 추출

- 앱.모델 이름 지정: 특정 모델 데이터만 추출

- 앱/모델명을 지정하지 않음: 프로젝트 전체 데이터베이스를 추출

- --format 옵션을 통해 출력 형식 지정 가능
  - 기본값: JSON
  - 예: --format yaml 사용 시 YAML 형식으로 출력

---

### dumpdata 명령어 예시

1)
```bash
$ python manage.py dumpdata --indent 4 articles.article > articles.json
```
- `articles` 앱의 `Article` 모델 데이터를 추출

- `--indent 4` : JSON 파일의 들여쓰기를 4칸으로 지정

- 실행 후 `articles.json` 파일이 프로젝트 폴더에 생성

- 파일 안에는 `Article` 모델의 모든 데이터가 JSON 형식으로 저장됨

- Fixtures 파일명(`articles.json`)은 자유롭게 지정 가능   

2)
```bash
$ python manage.py dumpdata --indent 4 articles.comment > comments.json
$ python manage.py dumpdata --indent 4 accounts.user > users.json
```

- articles 앱의 Comment 모델, accounts 앱의 User 모델 데이터를 각각 추출

- 결과적으로 다음과 같은 JSON 파일들이 생성됨:
  - articles.json
  - comments.json
  - users.json

- 이러한 파일들을 활용하면, 다른 개발자나 환경에서도 동일한 데이터 상태를 쉽게 복원할 수 있음

### dumpdata 정리

- `dumpdata` 명령어를 사용하면 프로젝트 내 특정 앱 혹은 모델에 대한 데이터를  
  JSON 등의 형식으로 추출할 수 있음  
- 추출된 파일은 이후 다른 환경에서 `loaddata` 명령어를 통해 불러올 수 있으며,  
  동일한 데이터 상태를 손쉽게 재현 가능  
- 이를 통해 **협업 시 데이터 일관성을 유지**하고,  
  **배포 환경에서도 동일한 초기 데이터 세팅을 보장**할 수 있음  

#### ✅ 핵심 요약
- 명령어: `python manage.py dumpdata [앱이름.모델이름] > 파일명.json`
- 출력 형식: JSON (기본값)
- 주요 활용:
  1. 데이터 백업 및 초기 세팅용  
  2. 협업 시 동일한 데이터 공유  
  3. 배포 전후 동일한 데이터 환경 보장

---

## loaddata

- `loaddata`는 `dumpdata` 명령어로 추출한 데이터를 다시 데이터베이스에 반영할 때 사용하는 명령어임  
- 저장된 Fixture 파일(JSON, YAML 등)을 불러와 데이터베이스를 복원할 수 있음  


### loaddata 기본 명령어

- 지정된 경로에 있는 Fixture 파일을 읽어 들여 데이터베이스에 데이터를 삽입함  
  ```bash
  $ python manage.py loaddata 파일경로
  ```
- 주로 JSON 형식의 데이터를 불러오며, 동일한 데이터 상태를 다른 환경에서도 재현할 수 있음  

### Fixture 파일의 기본 경로
- Fixtures 파일의 기본 경로
  - <u>`app_name/fixtures/`</u>
- Django는 각 앱 내부의 `fixtures` 폴더를 기본적으로 탐색함  
- 설치된 모든 앱 디렉토리의 `fixtures` 폴더에서 지정된 파일을 찾은 후 로드함  
- 즉, `app_name/fixtures/` 구조 내에 파일을 두면 자동으로 인식됨  

### ✅ 정리
- `dumpdata` → 데이터를 **추출**, `loaddata` → 데이터를 **복원**  
- 두 명령어를 함께 사용하면 초기 데이터 세팅과 협업 환경 통일에 용이함  
- 특히 팀 프로젝트나 배포 시 동일한 데이터베이스 상태를 유지하는 데 큰 도움이 됨

---

### loaddata 주의 사항

- `loaddata`를 실행하기 전에, **해당 모델에 대한 마이그레이션이 완료되어 있어야 함**  
  - 모델 구조가 일치하지 않으면 데이터를 불러올 때 에러가 발생할 수 있음  
- **같은 PK를 가진 데이터가 이미 존재하는 경우**, 중복 에러가 발생할 수 있음  
  - 이럴 때는 기존 데이터를 삭제하거나, 새로운 Fixture 파일을 사용해야 함  

---

### loaddata 정리

- `loaddata` 명령어는 `dumpdata`로 추출한 Fixture 파일을 **데이터베이스로 불러오는 명령어**  
- 개발 환경 세팅이나 협업 시, 동일한 데이터를 신속하게 복원할 수 있어 매우 유용함  
- 사용 전 **마이그레이션 상태와 인코딩 문제**를 반드시 확인해야 하며,  
  이를 미리 처리하면 데이터를 매끄럽게 복원 가능함  

---

# Improve query

**Improve query**
- 같은 결과를 얻기 위해 **데이터베이스(DB)에 보내는 쿼리의 개수를 최소화**하는 과정  
- 불필요하게 반복되는 쿼리를 줄임으로써 **성능 향상**과 **응답 시간 단축**을 목표로 함  
- 이를 통해 Django ORM에서 자주 발생하는 **N+1 Problem**을 해결할 수 있음  

---

### N+1 Problem

- 한 번의 쿼리로 기본 데이터를 가져온 후,  
  각 데이터와 관련된 추가 정보를 가져오기 위해 **N번의 추가 쿼리가 실행되는 상황**  
- 결과적으로 총 **N+1개의 쿼리**가 발생하여 성능 저하를 일으킴  

### 발생 원인
- ORM이 관련 객체(예: 외래키 관계 데이터)에 접근할 때  
  매번 개별적으로 쿼리를 수행하기 때문에 중복된 쿼리가 다수 발생함  

### 문제점
- 데이터의 양이 많을수록 **DB 부하가 심해지고 속도가 급격히 느려짐**  
- 대규모 서비스에서는 서버 자원 낭비와 성능 저하로 이어질 수 있음  

### 정리
- **N+1 Problem**은 ORM 환경에서 흔히 발생하는 비효율적인 쿼리 문제  
- 이를 해결하기 위해서는 **쿼리 최적화 기법(`select_related`, `prefetch_related`)** 등을 사용해야 함  
- 목표는 **같은 결과를 더 적은 쿼리로 얻는 것**, 즉 **데이터베이스 접근 효율화**

---

## annotate

### Django annotate
- Django ORM에서 SQL의 **GROUP BY** 기능을 활용하는 메서드  
- 쿼리셋의 각 객체에 **계산된 필드(추가 정보)** 를 함께 포함시켜 반환함  
- 이를 통해 각 객체별로 연산된 결과를 미리 계산하여  
  불필요한 반복 쿼리를 줄이고 효율적으로 데이터를 조회할 수 있음  

### 특징
- **각 행(row)** 별로 계산된 값을 새로운 필드로 추가함  
- 기존 필드 외에 **새로운 계산 필드**를 함께 반환하여,  
  데이터를 가져오면서 동시에 통계나 집계 결과를 확인 가능  
- **<u>집계 함수</u>**(Aggregate Functions)와 함께 자주 사용됨  
  - 대표적으로 `Count`, `Sum`, `Avg`, `Max`, `Min` 등이 있음  

### 활용 목적
- `annotate`를 사용하면 **N+1 Problem을 예방**하고  
  데이터 조회 시 DB 접근 횟수를 줄일 수 있음  
- 예를 들어, 각 게시글의 댓글 수를 미리 계산해 함께 가져오면  
  반복적인 쿼리 요청을 줄이고 페이지 렌더링 속도를 개선할 수 있음  

---

### annotate 예시

```python
Book.objects.annotate(num_authors=Count('authors'))
```

**동작 원리**
- `annotate`는 쿼리셋의 각 객체에 **새로운 계산 필드**를 추가함  
- 예를 들어, 책(`Book`) 객체에 연결된 저자(`authors`)의 수를 계산해  
  각 책마다 **저자 수를 나타내는 새로운 필드**를 생성할 수 있음  

**결과**
- 쿼리 결과로 반환되는 각 객체는 기존 데이터와 함께  
  새롭게 추가된 계산 필드를 포함함  
- 이렇게 추가된 필드는 마치 모델의 속성처럼 접근 가능하며,  
  예를 들어 `book.num_authors` 형태로 값을 확인할 수 있음  

**참고 사항**
- 새로 추가되는 필드명은 임의로 지정할 수 있으며,  
  지정하지 않으면 Django가 자동으로 기본 이름을 생성함  
- 이 방식은 데이터 통계나 요약 정보를 각 객체 단위로 함께 가져올 때 유용함  

**정리**
- `annotate`는 각 객체에 **집계 결과를 계산해 포함**시킬 수 있는 강력한 ORM 기능  
- 주로 `Count`, `Sum`, `Avg` 등과 함께 사용되어  
  **데이터를 효율적으로 요약·분석**할 수 있음  
- 반복 쿼리를 줄이고, ORM 레벨에서 **즉시 계산된 정보를 제공**함으로써  
  성능 최적화와 코드 단순화를 동시에 달성할 수 있음


---

## select_related

### 개념
- `select_related`는 **ForeignKey** 또는 **OneToOne** 관계에서 사용되는 Django ORM의 메서드임  
- 내부적으로 **INNER JOIN**을 사용하여, 관련 객체를 **한 번의 쿼리로 함께 불러옴**  
- 이를 통해 데이터 조회 시 **추가적인 쿼리 실행 없이 관련 데이터를 즉시 활용**할 수 있음  


### 동작 방식
```python
Book.objects.select_related('publisher')
```
- ForeignKey, OneToOne 관계의 데이터를 가져올 때  
  일반적으로 ORM은 각 객체에 대해 추가 쿼리를 실행함  
- 하지만 `select_related`를 사용하면,  
  관계된 테이블을 **JOIN하여 단일 쿼리로 모든 데이터**를 가져옴  
- 결과적으로 DB 접근 횟수가 줄어들고, **쿼리 효율과 성능이 향상됨**


### 특징
- 주로 **1:1** 또는 **1:N 관계에서 N쪽 데이터 접근 시** 사용됨  
- 예를 들어, 책(Book)과 출판사(Publisher)가 연결되어 있을 때  
  `select_related`를 사용하면 책 데이터를 가져올 때 출판사 정보도 함께 로드함  
- 이를 통해 `book.publisher.name`처럼 접근할 때 **추가 쿼리 없이 즉시 참조 가능**


### 정리
- `select_related`는 **JOIN 기반의 쿼리 최적화 도구**  
- 한 번의 쿼리로 **주 객체와 관련 객체를 동시에 조회**  
- **ForeignKey**, **OneToOne** 관계에서 특히 효과적  
- 결과적으로 **쿼리 수 감소 → 응답 속도 향상 → DB 부하 감소**라는 장점을 가짐


### N+1 Problem 상황 (심화)

#### 1. 문제 원인
- 게시글의 작성자 정보를 확인하기 위해,  
  각 게시글마다 추가적으로 데이터베이스에 쿼리를 요청하게 됨  
- 동일한 작성자가 여러 게시글을 작성했더라도,  
  각 게시글별로 작성자 정보를 반복 조회하면서 **중복된 쿼리**가 다수 발생함  
- 이러한 방식은 요청량이 많을수록 서버 성능에 부하를 주며,  
  결과적으로 페이지 로딩 속도가 저하되는 원인이 됨  

### select_related 적용

#### 1. 문제 해결 방식
- `select_related`를 사용하면,  
  게시글 데이터를 불러올 때 **작성자 정보(User)** 까지 **한 번의 쿼리로 함께 조회**할 수 있음  
- Django ORM은 내부적으로 **JOIN 쿼리**를 수행하여  
  게시글과 작성자 데이터를 동시에 가져옴  
- 이를 통해 각 게시글마다 별도의 쿼리를 실행할 필요가 없어짐  


#### 2. 효과
- 중복된 N+1 쿼리를 제거하여 데이터베이스 접근 횟수를 크게 줄임  
- 동일한 데이터를 조회할 때 속도와 효율이 향상됨  
- 특히 ForeignKey 관계(예: 게시글 → 작성자)에서 쿼리 최적화 효과가 큼  


### 정리
- N+1 Problem은 ORM의 반복적인 관계 조회로 발생하는 성능 문제  
- `select_related`를 사용하면 **ForeignKey** 및 **OneToOne** 관계 데이터를  
  한 번의 쿼리로 가져올 수 있어 **쿼리 수 감소 및 속도 개선** 가능  
- 결과적으로 **서버 부하를 줄이고, 페이지 렌더링 성능을 향상**시킬 수 있음

---


## prefetch_related


### 개념
- `prefetch_related`는 **SQL이 아닌 Python 레벨에서 JOIN을 수행**하는 Django ORM의 메서드임  
- 관련된 객체들을 **미리 가져와 메모리에 저장**함으로써,  
  반복적인 데이터베이스 접근을 줄이고 **성능을 향상**시킴  
- 주로 **ManyToMany** 또는 **역참조(N:1, 1:N) 관계**에서 사용됨  


### 동작 방식
- Django가 **두 번의 쿼리를 실행**하여 데이터를 효율적으로 결합함  
  1. 첫 번째 쿼리: 기본 객체(예: Book)를 조회  
  2. 두 번째 쿼리: 관련된 객체(예: Author)를 한꺼번에 조회  
- 이후 Python이 이 두 쿼리 결과를 메모리 상에서 결합하여,  
  각 객체 간의 관계를 미리 설정함  


### 특징
- `select_related`와 달리 **JOIN을 SQL 단계에서 수행하지 않음**  
- 대신 관련 데이터를 **별도의 쿼리로 미리 불러와 캐시 형태로 저장**  
- **ManyToManyField**, **역참조 관계**(예: User → Article 목록)에서 가장 효과적  


### 효과
- 관련 데이터를 미리 가져오기 때문에  
  `for` 반복문 등에서 관련 데이터를 접근하더라도  
  **추가적인 데이터베이스 쿼리가 발생하지 않음**  
- 결과적으로 대량의 관계형 데이터를 효율적으로 처리할 수 있음  

---

### 정리
- `prefetch_related`는 **N+1 문제를 해결하는 핵심 ORM 도구** 중 하나  
- **ManyToMany** 및 **역참조 관계**에서 데이터 조회 효율을 극대화함  
- DB 접근 횟수를 최소화하여 **쿼리 최적화 및 서버 성능 향상**에 기여함  
- 요약하자면:
  - `select_related` → SQL JOIN 기반 (ForeignKey, OneToOne)
  - `prefetch_related` → Python JOIN 기반 (ManyToMany, 역참조)
